import chokidar from "chokidar"
import fs from "fs"
import glob from "glob"
import fetch from "node-fetch"
import PQueue from "p-queue"
import path from "path"
import {
  MoisesSdkError
} from "./lib/moises-sdk-error.js"
import {
  ensureFolderExists,
  extractFileExtensionFromUrl,
  extractNameFromUrl,
  sleep,
} from "./lib/utils.js"

export default class Moises {
  constructor({
    apiKey,
    jobMonitorInterval = 1000,
    saveOutputToFolder = true,
    apiEndpoint,
  }) {
    this.jobMonitorInterval = jobMonitorInterval
    this.validInputFormats = "mp3|wav|m4a"
    this.saveOutputToFolder = saveOutputToFolder
    this.apiKey = apiKey
    this.apiEndpoint = apiEndpoint ?? "https://developer-api.moises.ai"
  }

  async apiCall(method, path, data) {
    const url = `${this.apiEndpoint}${path}`

    const headers = {
      "Content-Type": "application/json",
      Authorization: this.apiKey,
    }

    const response = await fetch(url, {
      method,
      headers,
      body: JSON.stringify(data),
    })

    const json = await response.json().catch(() => null)

    if (response.status !== 200) {
      throw new MoisesSdkError(json?.message || response.statusText)
    }

    return json
  }

  async uploadFile(fileLocation) {
    const { uploadUrl, downloadUrl } = await this.apiCall("GET", "/api/upload")

    await fetch(uploadUrl, {
      method: "PUT",
      body: fs.createReadStream(fileLocation),
    })

    return downloadUrl
  }

  async downloadFile(url, fileDestination) {
    await ensureFolderExists(fileDestination)

    const response = await fetch(url)
    const buffer = Buffer.from(await response.arrayBuffer())
    await fs.promises.writeFile(fileDestination, buffer)
  }

  async addJob(name, workflow, params) {
    const { id } = await this.apiCall("POST", "/api/job", {
      name,
      workflow,
      params,
    })
    return id
  }

  async auth() {
    return this.apiCall("GET", `/api/application`)
  }

  async processFile(workflow, origin, outputFolder) {
    const name = path.basename(origin).split(".").shift()
    const inputUrl = await this.uploadFile(origin)
    const jobId = await this.addJob(name, workflow, { inputUrl })
    const jobData = await this.waitForJobCompletion(jobId)
    await this.downloadJobResults(jobData, outputFolder)
    await this.deleteJob(jobId)
  }

  processFolder(workflow, inputFolder, outputFolder, options) {
    // This is needed because glob doesn't work with Windows paths
    if (process.platform === "win32") {
      inputFolder = inputFolder.replace(/\\/g, "/")
      outputFolder = outputFolder.replace(/\\/g, "/")
    }

    return new Promise(async (resolve, reject) => {
      let watcher
      const processFile = this.processFile.bind(this)
      const queue = new PQueue({ concurrency: options.concurrency ?? 5 })
      const report = {}

      if (options.signal) {
        options.signal.addEventListener("abort", async () => {
          if (options.watch) {
            watcher.close()
          }

          queue.clear()
          await queue.onIdle()
          resolve("Aborted")
        })
      }

      function addToQueue(file) {
        reportProgress(file, "pending")
        queue.add(async () => {
          try {
            reportProgress(file, "processing")
            const fileName = path.basename(file).split(".").shift()
            await processFile(workflow, file, `${outputFolder}/${fileName}`)
            reportProgress(file, "succeeded")
          } catch (error) {
            console.error(error)
            reportProgress(file, "failed")
          }
        })
      }

      function reportProgress(file, status) {
        report[file] = { status }
        if (options.onProgress) {
          const reportBreakdown = {
            pending: [],
            processing: [],
            succeeded: [],
            failed: [],
          }

          for (const filePath in report) {
            reportBreakdown[report[filePath].status].push(filePath)
          }

          options.onProgress(file, status, reportBreakdown)
        }
      }

      const globOptions = `${inputFolder}/*.@(mp3|wav|m4a)`

      if (options.watch) {
        watcher = chokidar.watch(globOptions).on("add", addToQueue)
      } else {
        glob(globOptions, options, async function (er, files) {
          for (const file of files) {
            addToQueue(file)
          }
          await queue.onIdle()
          resolve("Ended normally")
        })
      }
    })
  }

  async getJob(id) {
    return this.apiCall("GET", `/api/job/${id}`)
  }

  async listJobs(filters) {
    let params = new URLSearchParams("")
    if (filters) {
      for (const [key, values] of Object.entries(filters)) {
        for (const value in values) {
          params.append("key", value)
        }
      }
    }

    return this.apiCall("GET", `/api/job?${params.toString()}`)
  }

  async deleteJob(id) {
    return this.apiCall("DELETE", `/api/job/${id}`)
  }

  async waitForJobCompletion(id) {
    while (true) {
      const job = await this.getJob(id)
      if (job.status === "SUCCEEDED" || job.status === "FAILED") {
        return job
      }
      await sleep(this.jobMonitorInterval)
    }
  }

  async downloadJobResults(jobIdOrJobData, outputFolder) {
    let job =
      typeof jobIdOrJobData === "string"
        ? await this.getJob(jobIdOrJobData)
        : jobIdOrJobData

    if (job.status === "QUEUED" || job.status === "STARTED") {
      throw new MoisesSdkError(
        `Can't download job results: Job '${job.id}' is not completed`
      )
    }

    if (job.status === "FAILED") {
      throw new MoisesSdkError(
        `Can't download job results: Job '${job.id}' failed`
      )
    }

    const downloads = []
    const downloadResult = {}
    const resultJsonDownloads = {}

    for (const result in job.result) {
      const value = job.result[result]

      if (value.startsWith("https://")) {
        const fileName = this.saveOutputToFolder
          ? `${result}.${extractFileExtensionFromUrl(value)}`
          : `${extractNameFromUrl(value)}`
        const downloadDestination = `${outputFolder}/${fileName}`
        downloads.push(this.downloadFile(value, downloadDestination))
        downloadResult[result] = downloadDestination
        resultJsonDownloads[result] = `./${fileName}`
      }
    }

    await Promise.all(downloads)

    const resultJson = JSON.stringify({ ...job.result, ...resultJsonDownloads })
    fs.writeFileSync(`${outputFolder}/workflow.result.json`, resultJson)

    return downloadResult
  }
}
